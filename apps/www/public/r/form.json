{
  "name": "form",
  "type": "registry:component",
  "dependencies": [
    "react",
    "react-dom",
    "@fragment_ui/ui"
  ],
  "files": [
    {
      "path": "components/ui/Form.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport { FormField, FormFieldProps } from \"./form-field\";\nimport { FormArray, FormArrayProps } from \"./form-array\";\nimport { ConditionalField, useConditionalShow, ConditionalRule } from \"./form-conditional\";\nimport { validateValue, ValidationRules } from \"./form-validation\";\nimport clsx from \"clsx\";\n\nexport interface FormEnhancedProps {\n  children: React.ReactNode;\n  onSubmit?: (data: FormData) => void;\n  onError?: (errors: Record<string, string>) => void;\n  className?: string;\n  validationMode?: \"onChange\" | \"onBlur\" | \"onSubmit\";\n  validateOnMount?: boolean;\n}\n\nexport interface FormContextValue {\n  values: Record<string, any>;\n  errors: Record<string, string>;\n  touched: Record<string, boolean>;\n  setValue: (name: string, value: any) => void;\n  setError: (name: string, error: string | undefined) => void;\n  setTouched: (name: string, touched: boolean) => void;\n  validateField: (name: string, value: any, rules?: ValidationRules) => void;\n  validationMode: \"onChange\" | \"onBlur\" | \"onSubmit\";\n}\n\nconst FormContext = React.createContext<FormContextValue | null>(null);\n\nexport function useFormContext() {\n  const context = React.useContext(FormContext);\n  if (!context) {\n    throw new Error(\"useFormContext must be used within FormEnhanced\");\n  }\n  return context;\n}\n\nexport function FormEnhanced({\n  children,\n  onSubmit,\n  onError,\n  className,\n  validationMode = \"onSubmit\",\n  validateOnMount = false,\n}: FormEnhancedProps) {\n  const [values, setValues] = React.useState<Record<string, any>>({});\n  const [errors, setErrors] = React.useState<Record<string, string>>({});\n  const [touched, setTouchedState] = React.useState<Record<string, boolean>>({});\n  const [fieldRules, setFieldRules] = React.useState<Record<string, ValidationRules>>({});\n\n  const setValue = React.useCallback((name: string, value: any) => {\n    setValues((prev) => ({ ...prev, [name]: value }));\n    \n    // Clear error when value changes\n    if (errors[name]) {\n      setErrors((prev) => {\n        const newErrors = { ...prev };\n        delete newErrors[name];\n        return newErrors;\n      });\n    }\n  }, [errors]);\n\n  const setError = React.useCallback((name: string, error: string | undefined) => {\n    setErrors((prev) => {\n      if (error) {\n        return { ...prev, [name]: error };\n      }\n      const newErrors = { ...prev };\n      delete newErrors[name];\n      return newErrors;\n    });\n  }, []);\n\n  const handleSetTouched = React.useCallback((name: string, isTouched: boolean) => {\n    setTouchedState((prev) => ({ ...prev, [name]: isTouched }));\n  }, []);\n\n  const validateField = React.useCallback(\n    (name: string, value: any, rules?: ValidationRules) => {\n      if (rules) {\n        setFieldRules((prev) => ({ ...prev, [name]: rules }));\n      }\n      const rulesToUse = rules || fieldRules[name];\n      const error = validateValue(value, rulesToUse);\n      setError(name, error);\n      return !error;\n    },\n    [fieldRules, setError]\n  );\n\n  const validateAll = React.useCallback(() => {\n    const newErrors: Record<string, string> = {};\n    let isValid = true;\n\n    Object.entries(fieldRules).forEach(([name, rules]) => {\n      const error = validateValue(values[name], rules);\n      if (error) {\n        newErrors[name] = error;\n        isValid = false;\n      }\n    });\n\n    setErrors(newErrors);\n    return isValid;\n  }, [values, fieldRules]);\n\n  const handleSubmit = React.useCallback(\n    (e: React.FormEvent<HTMLFormElement>) => {\n      e.preventDefault();\n      \n      const formData = new FormData(e.currentTarget);\n      const formValues: Record<string, any> = {};\n      \n      // Collect all form values\n      formData.forEach((value, key) => {\n        formValues[key] = value;\n      });\n      \n      // Merge with controlled values\n      const allValues = { ...formValues, ...values };\n\n      // Validate all fields\n      const isValid = validateAll();\n      if (!isValid) {\n        // Get current errors after validation\n        const currentErrors: Record<string, string> = {};\n        Object.entries(fieldRules).forEach(([name, rules]) => {\n          const error = validateValue(allValues[name], rules);\n          if (error) {\n            currentErrors[name] = error;\n          }\n        });\n        setErrors(currentErrors);\n        onError?.(currentErrors);\n        return;\n      }\n\n      // Convert to FormData for submission\n      const submitData = new FormData();\n      Object.entries(allValues).forEach(([key, value]) => {\n        if (value !== undefined && value !== null) {\n          submitData.append(key, String(value));\n        }\n      });\n\n      onSubmit?.(submitData);\n    },\n    [values, errors, validateAll, onSubmit, onError]\n  );\n\n  const contextValue: FormContextValue = React.useMemo(\n    () => ({\n      values,\n      errors,\n      touched,\n      setValue,\n      setError,\n      setTouched: handleSetTouched,\n      validateField,\n      validationMode,\n    }),\n    [values, errors, touched, setValue, setError, handleSetTouched, validateField, validationMode]\n  );\n\n  React.useEffect(() => {\n    if (validateOnMount) {\n      validateAll();\n    }\n  }, [validateOnMount, validateAll]);\n\n  return (\n    <FormContext.Provider value={contextValue}>\n      <form onSubmit={handleSubmit} className={className}>\n        {children}\n      </form>\n    </FormContext.Provider>\n  );\n}\n\nexport interface FormFieldEnhancedProps extends Omit<FormFieldProps, \"error\"> {\n  name: string;\n  rules?: ValidationRules;\n  conditional?: ConditionalRule[] | boolean;\n}\n\nexport function FormFieldEnhanced({\n  name,\n  rules,\n  conditional,\n  children,\n  ...props\n}: FormFieldEnhancedProps) {\n  const { values, errors, touched, setValue, setTouched: handleSetTouched, validateField, validationMode } =\n    useFormContext();\n  const [localValue, setLocalValue] = React.useState(values[name] || \"\");\n\n  const shouldShow = useConditionalShow(conditional ?? true, values);\n  const error = errors[name];\n  const isTouched = touched[name];\n\n  React.useEffect(() => {\n    if (values[name] !== localValue) {\n      setLocalValue(values[name] || \"\");\n    }\n  }, [values, name, localValue]);\n\n  const handleChange = React.useCallback(\n    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {\n      const newValue = e.target.value;\n      setLocalValue(newValue);\n      setValue(name, newValue);\n\n      if (validationMode === \"onChange\" && rules) {\n        validateField(name, newValue, rules);\n      }\n    },\n    [name, setValue, validateField, rules, validationMode]\n  );\n\n  const handleBlur = React.useCallback(() => {\n    handleSetTouched(name, true);\n    if (validationMode === \"onBlur\" && rules) {\n      validateField(name, localValue, rules);\n    }\n  }, [name, handleSetTouched, validateField, localValue, rules, validationMode]);\n\n  if (!shouldShow) return null;\n\n  return (\n    <FormField {...props} error={isTouched ? error : undefined}>\n      {React.cloneElement(children as React.ReactElement, {\n        name,\n        value: localValue,\n        onChange: handleChange,\n        onBlur: handleBlur,\n      })}\n    </FormField>\n  );\n}\n\n// FormArray, ConditionalField, and useConditionalShow are already exported from their respective modules\n// Import them directly from './form-array' and './form-conditional' instead\n\n"
    }
  ]
}