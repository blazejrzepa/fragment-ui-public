{
  "name": "form-field",
  "type": "registry:block",
  "dependencies": [
    "react",
    "react-dom"
  ],
  "files": [
    {
      "path": "components/ui/form-field.tsx",
      "content": "import * as React from \"react\";\nimport clsx from \"clsx\";\nimport { Input } from \"./input\";\nimport { Textarea } from \"./textarea\";\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from \"./select\";\nimport { RadioGroup, Radio } from \"./radio\";\n\nexport interface FormFieldProps {\n  label?: string;\n  error?: string;\n  helperText?: string;\n  required?: boolean;\n  children: React.ReactNode;\n  className?: string;\n}\n\nexport const FormField = React.forwardRef<HTMLDivElement, FormFieldProps>(\n  function FormField({ label, error, helperText, required, children, className }, ref) {\n    const id = React.useId();\n\n    return (\n      <div ref={ref} className={clsx(\"space-y-2\", className)}>\n        {label && (\n          <label\n            htmlFor={id}\n            className=\"text-sm font-medium text-[color:var(--color-fg-base)]\"\n          >\n            {label}\n            {required && <span className=\"ml-1 text-[color:var(--color-accent-red)]\">*</span>}\n          </label>\n        )}\n        <div>\n          {React.cloneElement(children as React.ReactElement, {\n            id,\n            \"aria-invalid\": error ? \"true\" : undefined,\n            \"aria-describedby\": error || helperText ? `${id}-description` : undefined,\n          })}\n        </div>\n        {(error || helperText) && (\n          <p\n            id={`${id}-description`}\n            className={clsx(\n              \"text-xs\",\n              error\n                ? \"text-[color:var(--color-accent-red)]\"\n                : \"text-[color:var(--color-fg-muted)]\"\n            )}\n          >\n            {error || helperText}\n          </p>\n        )}\n      </div>\n    );\n  }\n);\n\nexport interface FormFieldInputProps extends React.ComponentProps<typeof Input> {\n  label?: string;\n  error?: string;\n  helperText?: string;\n  required?: boolean;\n}\n\nexport const FormFieldInput = React.forwardRef<HTMLInputElement, FormFieldInputProps>(\n  function FormFieldInput({ label, error, helperText, required, className, ...props }, ref) {\n    return (\n      <FormField label={label} error={error} helperText={helperText} required={required}>\n        <Input\n          ref={ref}\n          className={clsx(error && \"border-[color:var(--color-accent-red)]\", className)}\n          {...props}\n        />\n      </FormField>\n    );\n  }\n);\n\nexport interface FormFieldTextareaProps extends React.ComponentProps<typeof Textarea> {\n  label?: string;\n  error?: string;\n  helperText?: string;\n  required?: boolean;\n}\n\nexport const FormFieldTextarea = React.forwardRef<HTMLTextAreaElement, FormFieldTextareaProps>(\n  function FormFieldTextarea({ label, error, helperText, required, className, ...props }, ref) {\n    return (\n      <FormField label={label} error={error} helperText={helperText} required={required}>\n        <Textarea\n          ref={ref}\n          className={clsx(error && \"border-[color:var(--color-accent-red)]\", className)}\n          {...props}\n        />\n      </FormField>\n    );\n  }\n);\n\n"
    },
    {
      "path": "lib/form-validation.ts",
      "content": "/**\n * Form validation utilities\n */\n\nexport type ValidationRule<T = string> = {\n  message: string;\n  validate: (value: T) => boolean;\n};\n\nexport interface ValidationRules {\n  required?: { message?: string };\n  minLength?: { value: number; message?: string };\n  maxLength?: { value: number; message?: string };\n  email?: { message?: string };\n  pattern?: { value: RegExp; message?: string };\n  custom?: ValidationRule[];\n}\n\n/**\n * Validate a single value against rules\n */\nexport function validateValue<T = string>(\n  value: T,\n  rules?: ValidationRules\n): string | undefined {\n  if (!rules) return undefined;\n\n  // Required\n  if (rules.required) {\n    if (value === undefined || value === null || value === \"\") {\n      return rules.required.message || \"This field is required\";\n    }\n  }\n\n  // Skip other validations if value is empty (required handles empty)\n  if (value === undefined || value === null || value === \"\") {\n    return undefined;\n  }\n\n  const stringValue = String(value);\n\n  // Min length\n  if (rules.minLength) {\n    if (stringValue.length < rules.minLength.value) {\n      return (\n        rules.minLength.message ||\n        `Must be at least ${rules.minLength.value} characters`\n      );\n    }\n  }\n\n  // Max length\n  if (rules.maxLength) {\n    if (stringValue.length > rules.maxLength.value) {\n      return (\n        rules.maxLength.message ||\n        `Must be no more than ${rules.maxLength.value} characters`\n      );\n    }\n  }\n\n  // Email\n  if (rules.email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(stringValue)) {\n      return rules.email.message || \"Invalid email address\";\n    }\n  }\n\n  // Pattern\n  if (rules.pattern) {\n    if (!rules.pattern.value.test(stringValue)) {\n      return rules.pattern.message || \"Invalid format\";\n    }\n  }\n\n  // Custom validators\n  if (rules.custom) {\n    for (const rule of rules.custom) {\n      // Type assertion needed because custom validators might have different generic types\n      if (!rule.validate(value as any)) {\n        return rule.message;\n      }\n    }\n  }\n\n  return undefined;\n}\n\n/**\n * Common validation presets\n */\nexport const validators = {\n  required: (message = \"This field is required\"): ValidationRules => ({\n    required: { message },\n  }),\n\n  email: (message = \"Invalid email address\"): ValidationRules => ({\n    email: { message },\n  }),\n\n  minLength: (length: number, message?: string): ValidationRules => ({\n    minLength: { value: length, message },\n  }),\n\n  maxLength: (length: number, message?: string): ValidationRules => ({\n    maxLength: { value: length, message },\n  }),\n\n  pattern: (regex: RegExp, message = \"Invalid format\"): ValidationRules => ({\n    pattern: { value: regex, message },\n  }),\n\n  compose: (...rules: ValidationRules[]): ValidationRules => {\n    return rules.reduce((acc, rule) => ({ ...acc, ...rule }), {});\n  },\n};\n\n"
    }
  ]
}