{
  "name": "taginput",
  "type": "registry:component",
  "dependencies": [
    "react",
    "react-dom",
    "@fragment_ui/ui"
  ],
  "files": [
    {
      "path": "components/ui/TagInput.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport clsx from \"clsx\";\nimport { X } from \"lucide-react\";\nimport { Badge } from \"./badge\";\nimport { Input } from \"./input\";\n\nexport interface TagInputProps {\n  value?: string[];\n  defaultValue?: string[];\n  onChange?: (tags: string[]) => void;\n  placeholder?: string;\n  disabled?: boolean;\n  maxTags?: number;\n  maxLength?: number; // max length per tag\n  separator?: string | RegExp; // separator to split tags (e.g., \",\", \" \", /[,\\s]/)\n  allowDuplicates?: boolean;\n  validate?: (tag: string) => boolean | string; // return true if valid, or error message string\n  className?: string;\n  inputClassName?: string;\n  tagClassName?: string;\n  onTagAdd?: (tag: string) => void;\n  onTagRemove?: (tag: string) => void;\n}\n\nexport const TagInput = React.memo(\n  React.forwardRef<HTMLDivElement, TagInputProps>(\n    function TagInput(\n    {\n      value: controlledValue,\n      defaultValue,\n      onChange,\n      placeholder = \"Add tags...\",\n      disabled = false,\n      maxTags,\n      maxLength,\n      separator = /[,\\s]+/,\n      allowDuplicates = false,\n      validate,\n      className,\n      inputClassName,\n      tagClassName,\n      onTagAdd,\n      onTagRemove,\n      ...props\n    },\n    ref\n  ) {\n    const [uncontrolledValue, setUncontrolledValue] = React.useState<string[]>(\n      defaultValue ?? []\n    );\n    const [inputValue, setInputValue] = React.useState(\"\");\n    const [error, setError] = React.useState<string | null>(null);\n    const inputRef = React.useRef<HTMLInputElement>(null);\n\n    const isControlled = controlledValue !== undefined;\n    const tags = isControlled ? controlledValue : uncontrolledValue;\n\n    const updateTags = React.useCallback(\n      (newTags: string[]) => {\n        if (!isControlled) {\n          setUncontrolledValue(newTags);\n        }\n        onChange?.(newTags);\n      },\n      [isControlled, onChange]\n    );\n\n    const addTag = React.useCallback(\n      (tag: string) => {\n        const trimmedTag = tag.trim();\n\n        if (!trimmedTag) return;\n\n        // Check max length\n        if (maxLength && trimmedTag.length > maxLength) {\n          setError(`Tag must be ${maxLength} characters or less`);\n          return;\n        }\n\n        // Check duplicates\n        if (!allowDuplicates && tags.includes(trimmedTag)) {\n          setError(\"Tag already exists\");\n          return;\n        }\n\n        // Validate tag\n        if (validate) {\n          const validationResult = validate(trimmedTag);\n          if (validationResult !== true) {\n            setError(typeof validationResult === \"string\" ? validationResult : \"Invalid tag\");\n            return;\n          }\n        }\n\n        // Check max tags\n        if (maxTags && tags.length >= maxTags) {\n          setError(`Maximum ${maxTags} tags allowed`);\n          return;\n        }\n\n        const newTags = [...tags, trimmedTag];\n        updateTags(newTags);\n        setInputValue(\"\");\n        setError(null);\n        onTagAdd?.(trimmedTag);\n      },\n      [tags, maxLength, allowDuplicates, validate, maxTags, updateTags, onTagAdd]\n    );\n\n    const removeTag = React.useCallback(\n      (tagToRemove: string) => {\n        const newTags = tags.filter((tag) => tag !== tagToRemove);\n        updateTags(newTags);\n        onTagRemove?.(tagToRemove);\n      },\n      [tags, updateTags, onTagRemove]\n    );\n\n    const handleInputChange = React.useCallback(\n      (e: React.ChangeEvent<HTMLInputElement>) => {\n        const newValue = e.target.value;\n        setInputValue(newValue);\n        setError(null);\n\n        // Auto-split on separator\n        if (separator && typeof separator === \"string\") {\n          if (newValue.includes(separator)) {\n            const parts = newValue.split(separator);\n            const validParts = parts.filter((part) => part.trim());\n            if (validParts.length > 0) {\n              // Add all tags at once\n              validParts.forEach((part) => {\n                const trimmedTag = part.trim();\n                if (trimmedTag) {\n                  // Check max length\n                  if (maxLength && trimmedTag.length > maxLength) {\n                    setError(`Tag must be ${maxLength} characters or less`);\n                    return;\n                  }\n\n                  // Check duplicates\n                  if (!allowDuplicates && tags.includes(trimmedTag)) {\n                    setError(\"Tag already exists\");\n                    return;\n                  }\n\n                  // Validate tag\n                  if (validate) {\n                    const validationResult = validate(trimmedTag);\n                    if (validationResult !== true) {\n                      setError(typeof validationResult === \"string\" ? validationResult : \"Invalid tag\");\n                      return;\n                    }\n                  }\n                }\n              });\n\n              // If no errors, add all tags\n              if (!error) {\n                const newTags = [...tags];\n                validParts.forEach((part) => {\n                  const trimmedTag = part.trim();\n                  if (trimmedTag && (!maxLength || trimmedTag.length <= maxLength) && (allowDuplicates || !tags.includes(trimmedTag))) {\n                    if (!validate || validate(trimmedTag) === true) {\n                      if (!maxTags || newTags.length < maxTags) {\n                        newTags.push(trimmedTag);\n                        onTagAdd?.(trimmedTag);\n                      }\n                    }\n                  }\n                });\n                if (newTags.length > tags.length) {\n                  updateTags(newTags);\n                }\n              }\n              setInputValue(\"\");\n            }\n          }\n        } else if (separator instanceof RegExp) {\n          const parts = newValue.split(separator);\n          if (parts.length > 1) {\n            const validParts = parts.filter((part) => part.trim());\n            if (validParts.length > 0) {\n              // Add all tags at once\n              const newTags = [...tags];\n              validParts.forEach((part) => {\n                const trimmedTag = part.trim();\n                if (trimmedTag && (!maxLength || trimmedTag.length <= maxLength) && (allowDuplicates || !tags.includes(trimmedTag))) {\n                  if (!validate || validate(trimmedTag) === true) {\n                    if (!maxTags || newTags.length < maxTags) {\n                      newTags.push(trimmedTag);\n                      onTagAdd?.(trimmedTag);\n                    }\n                  }\n                }\n              });\n              if (newTags.length > tags.length) {\n                updateTags(newTags);\n              }\n              setInputValue(\"\");\n            }\n          }\n        }\n      },\n      [separator, tags, maxLength, allowDuplicates, validate, maxTags, error, updateTags, onTagAdd]\n    );\n\n    const handleInputKeyDown = React.useCallback(\n      (e: React.KeyboardEvent<HTMLInputElement>) => {\n        if (disabled) return;\n\n        // Add tag on Enter or comma\n        if (e.key === \"Enter\" || e.key === \",\") {\n          e.preventDefault();\n          if (inputValue.trim()) {\n            addTag(inputValue);\n          }\n        }\n\n        // Remove last tag on Backspace when input is empty\n        if (e.key === \"Backspace\" && !inputValue && tags.length > 0) {\n          removeTag(tags[tags.length - 1]);\n        }\n\n        // Escape to clear input\n        if (e.key === \"Escape\") {\n          setInputValue(\"\");\n          setError(null);\n        }\n      },\n      [disabled, inputValue, tags, addTag, removeTag]\n    );\n\n    const handleInputBlur = React.useCallback(() => {\n      // Add tag on blur if input has value\n      if (inputValue.trim()) {\n        addTag(inputValue);\n      }\n      setError(null);\n    }, [inputValue, addTag]);\n\n    return (\n      <div ref={ref} className={clsx(\"w-full\", className)} {...props}>\n        <div\n          className={clsx(\n            \"flex flex-wrap items-center gap-[var(--space-2)] min-h-[2.5rem] w-full rounded-[var(--radius-md)] border border-[color:var(--color-border-base)] bg-[color:var(--color-surface-1)] px-[var(--space-3)] py-[var(--space-2)]\",\n            disabled && \"opacity-60 cursor-not-allowed\",\n            error && \"border-[color:var(--color-status-error-border)]\"\n          )}\n          onClick={() => {\n            if (!disabled && inputRef.current) {\n              inputRef.current.focus();\n            }\n          }}\n        >\n          {/* Tags */}\n          {tags.map((tag, index) => (\n            <Badge\n              key={`${tag}-${index}`}\n              variant=\"outline\"\n              className={clsx(\n                \"flex items-center gap-[var(--space-1)] px-[var(--space-2)] py-[var(--space-0-5)]\",\n                tagClassName\n              )}\n            >\n              <span>{tag}</span>\n              {!disabled && (\n                <button\n                  type=\"button\"\n                  onClick={(e) => {\n                    e.stopPropagation();\n                    removeTag(tag);\n                  }}\n                  className=\"ml-[var(--space-1)] rounded-full hover:bg-[color:var(--color-surface-2)] p-[var(--space-0-5)] transition-colors duration-[var(--motion-duration-base)]\"\n                  aria-label={`Remove ${tag}`}\n                >\n                  <X className=\"h-3 w-3\" />\n                </button>\n              )}\n            </Badge>\n          ))}\n\n          {/* Input */}\n          <input\n            ref={inputRef}\n            type=\"text\"\n            value={inputValue}\n            onChange={handleInputChange}\n            onKeyDown={handleInputKeyDown}\n            onBlur={handleInputBlur}\n            disabled={disabled}\n            placeholder={tags.length === 0 ? placeholder : \"\"}\n            className={clsx(\n              \"flex-1 min-w-[120px] bg-transparent outline-none text-sm\",\n              \"placeholder:text-[color:var(--color-fg-muted)]\",\n              inputClassName\n            )}\n            aria-label=\"Add tag\"\n          />\n        </div>\n\n        {/* Error Message */}\n        {error && (\n          <p className=\"mt-[var(--space-1)] text-xs text-[color:var(--color-status-error-fg)]\">{error}</p>\n        )}\n\n        {/* Helper Text */}\n        {maxTags && (\n          <p className=\"mt-[var(--space-1)] text-xs text-[color:var(--color-fg-muted)]\">\n            {tags.length} / {maxTags} tags\n          </p>\n        )}\n      </div>\n    );\n  }\n  )\n);\n\nTagInput.displayName = \"TagInput\";\n\n"
    }
  ]
}