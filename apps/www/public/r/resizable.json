{
  "name": "resizable",
  "type": "registry:component",
  "dependencies": [
    "react",
    "react-dom",
    "@fragment_ui/ui"
  ],
  "files": [
    {
      "path": "components/ui/Resizable.tsx",
      "content": "\"use client\";\n\nimport * as React from \"react\";\nimport clsx from \"clsx\";\n\nexport interface ResizableProps {\n  children: React.ReactNode;\n  defaultSize?: { width?: number; height?: number };\n  minSize?: { width?: number; height?: number };\n  maxSize?: { width?: number; height?: number };\n  direction?: \"horizontal\" | \"vertical\" | \"both\";\n  className?: string;\n  onResize?: (size: { width: number; height: number }) => void;\n}\n\nexport interface ResizableHandleProps {\n  className?: string;\n  disabled?: boolean;\n}\n\nexport interface ResizablePanelProps {\n  children: React.ReactNode;\n  defaultSize?: number;\n  minSize?: number;\n  maxSize?: number;\n  defaultSizePx?: number; // Fixed pixel size instead of percentage\n  minSizePx?: number; // Fixed pixel min size\n  className?: string;\n}\n\nconst ResizableContext = React.createContext<{\n  direction: \"horizontal\" | \"vertical\" | \"both\";\n  isResizing: boolean;\n  setIsResizing: (resizing: boolean) => void;\n}>({\n  direction: \"horizontal\",\n  isResizing: false,\n  setIsResizing: () => {},\n});\n\nexport const Resizable = React.forwardRef<HTMLDivElement, ResizableProps>(\n  function Resizable(\n    {\n      children,\n      defaultSize,\n      minSize,\n      maxSize,\n      direction = \"horizontal\",\n      className,\n      onResize,\n    },\n    ref\n  ) {\n    const [isResizing, setIsResizing] = React.useState(false);\n    const containerRef = React.useRef<HTMLDivElement>(null);\n    const [size, setSize] = React.useState(defaultSize || { width: undefined, height: undefined });\n\n    React.useEffect(() => {\n      if (onResize && size.width !== undefined && size.height !== undefined) {\n        onResize({ width: size.width, height: size.height });\n      }\n    }, [size, onResize]);\n\n    return (\n      <ResizableContext.Provider value={{ direction, isResizing, setIsResizing }}>\n        <div\n          ref={ref || containerRef}\n          className={clsx(\n            \"relative\",\n            direction === \"horizontal\" && \"flex flex-row\",\n            direction === \"vertical\" && \"flex flex-col\",\n            isResizing && \"select-none\",\n            className\n          )}\n          style={{\n            width: size.width,\n            height: size.height,\n          }}\n        >\n          {children}\n        </div>\n      </ResizableContext.Provider>\n    );\n  }\n);\n\nResizable.displayName = \"Resizable\";\n\nexport const ResizableHandle = React.forwardRef<HTMLDivElement, ResizableHandleProps>(\n  function ResizableHandle({ className, disabled = false, ...props }, ref) {\n    const { direction, isResizing, setIsResizing } = React.useContext(ResizableContext);\n    const handleRef = React.useRef<HTMLDivElement>(null);\n    const startPos = React.useRef<{ x: number; y: number } | null>(null);\n    const prevPanelRef = React.useRef<HTMLElement | null>(null);\n    const nextPanelRef = React.useRef<HTMLElement | null>(null);\n    const containerRef = React.useRef<HTMLElement | null>(null);\n    const startSizes = React.useRef<{ prev: number; next: number; container: number } | null>(null);\n\n    const handleMouseDown = React.useCallback(\n      (e: React.MouseEvent) => {\n        if (disabled) return;\n        e.preventDefault();\n        setIsResizing(true);\n        startPos.current = { x: e.clientX, y: e.clientY };\n        const handle = (ref ? (ref as React.RefObject<HTMLDivElement>).current : handleRef.current);\n        if (!handle) return;\n        \n        const container = handle.parentElement;\n        if (!container) return;\n        containerRef.current = container;\n        \n        // Find previous and next panels\n        const siblings = Array.from(container.children);\n        const handleIndex = siblings.indexOf(handle);\n        prevPanelRef.current = handleIndex > 0 ? (siblings[handleIndex - 1] as HTMLElement) : null;\n        nextPanelRef.current = handleIndex < siblings.length - 1 ? (siblings[handleIndex + 1] as HTMLElement) : null;\n        \n        if (prevPanelRef.current && nextPanelRef.current) {\n          const containerSize = direction === \"horizontal\" ? container.offsetWidth : container.offsetHeight;\n          const prevSize = direction === \"horizontal\" \n            ? prevPanelRef.current.offsetWidth \n            : prevPanelRef.current.offsetHeight;\n          const nextSize = direction === \"horizontal\" \n            ? nextPanelRef.current.offsetWidth \n            : nextPanelRef.current.offsetHeight;\n          \n          startSizes.current = {\n            prev: prevSize,\n            next: nextSize,\n            container: containerSize,\n          };\n        }\n      },\n      [disabled, setIsResizing, ref, direction]\n    );\n\n    React.useEffect(() => {\n      if (!isResizing) return;\n\n      const handleMouseMove = (e: MouseEvent) => {\n        if (!startPos.current || !startSizes.current || !prevPanelRef.current || !nextPanelRef.current || !containerRef.current) return;\n\n        const deltaX = e.clientX - startPos.current.x;\n        const deltaY = e.clientY - startPos.current.y;\n\n        if (direction === \"horizontal\") {\n          const delta = deltaX;\n          const newPrevSize = startSizes.current.prev + delta;\n          const newNextSize = startSizes.current.next - delta;\n          \n          // Calculate percentages\n          const prevPercent = (newPrevSize / startSizes.current.container) * 100;\n          const nextPercent = (newNextSize / startSizes.current.container) * 100;\n          \n          // Apply min/max constraints from data attributes\n          let prevMin = 0;\n          let prevMax = 100;\n          let nextMin = 0;\n          let nextMax = 100;\n          \n          // Check for pixel-based min size\n          if (prevPanelRef.current.dataset.minSizePx) {\n            const minPx = parseFloat(prevPanelRef.current.dataset.minSizePx);\n            prevMin = (minPx / startSizes.current.container) * 100;\n          } else if (prevPanelRef.current.dataset.minSize) {\n            prevMin = parseFloat(prevPanelRef.current.dataset.minSize);\n          }\n          \n          if (prevPanelRef.current.dataset.maxSize) {\n            prevMax = parseFloat(prevPanelRef.current.dataset.maxSize);\n          }\n          \n          if (nextPanelRef.current.dataset.minSizePx) {\n            const minPx = parseFloat(nextPanelRef.current.dataset.minSizePx);\n            nextMin = (minPx / startSizes.current.container) * 100;\n          } else if (nextPanelRef.current.dataset.minSize) {\n            nextMin = parseFloat(nextPanelRef.current.dataset.minSize);\n          }\n          \n          if (nextPanelRef.current.dataset.maxSize) {\n            nextMax = parseFloat(nextPanelRef.current.dataset.maxSize);\n          }\n          \n          const constrainedPrev = Math.max(prevMin, Math.min(prevMax, prevPercent));\n          const constrainedNext = Math.max(nextMin, Math.min(nextMax, nextPercent));\n          \n          // If panel has defaultSizePx, use pixels instead of percentage when resizing\n          const prevDefaultSizePx = prevPanelRef.current.dataset.defaultSizePx;\n          const nextDefaultSizePx = nextPanelRef.current.dataset.defaultSizePx;\n          \n          if (prevDefaultSizePx) {\n            // Convert percentage back to pixels for panels with defaultSizePx\n            const prevPx = (constrainedPrev / 100) * startSizes.current.container;\n            prevPanelRef.current.style.flex = `0 0 ${prevPx}px`;\n          } else {\n          prevPanelRef.current.style.flex = `0 0 ${constrainedPrev}%`;\n          }\n          \n          if (nextDefaultSizePx) {\n            // Convert percentage back to pixels for panels with defaultSizePx\n            const nextPx = (constrainedNext / 100) * startSizes.current.container;\n            nextPanelRef.current.style.flex = `0 0 ${nextPx}px`;\n          } else {\n          nextPanelRef.current.style.flex = `0 0 ${constrainedNext}%`;\n          }\n        }\n        \n        if (direction === \"vertical\") {\n          const delta = deltaY;\n          const newPrevSize = startSizes.current.prev + delta;\n          const newNextSize = startSizes.current.next - delta;\n          \n          // Calculate percentages\n          const prevPercent = (newPrevSize / startSizes.current.container) * 100;\n          const nextPercent = (newNextSize / startSizes.current.container) * 100;\n          \n          // Apply min/max constraints from data attributes\n          let prevMin = 0;\n          let prevMax = 100;\n          let nextMin = 0;\n          let nextMax = 100;\n          \n          // Check for pixel-based min size\n          if (prevPanelRef.current.dataset.minSizePx) {\n            const minPx = parseFloat(prevPanelRef.current.dataset.minSizePx);\n            prevMin = (minPx / startSizes.current.container) * 100;\n          } else if (prevPanelRef.current.dataset.minSize) {\n            prevMin = parseFloat(prevPanelRef.current.dataset.minSize);\n          }\n          \n          if (prevPanelRef.current.dataset.maxSize) {\n            prevMax = parseFloat(prevPanelRef.current.dataset.maxSize);\n          }\n          \n          if (nextPanelRef.current.dataset.minSizePx) {\n            const minPx = parseFloat(nextPanelRef.current.dataset.minSizePx);\n            nextMin = (minPx / startSizes.current.container) * 100;\n          } else if (nextPanelRef.current.dataset.minSize) {\n            nextMin = parseFloat(nextPanelRef.current.dataset.minSize);\n          }\n          \n          if (nextPanelRef.current.dataset.maxSize) {\n            nextMax = parseFloat(nextPanelRef.current.dataset.maxSize);\n          }\n          \n          const constrainedPrev = Math.max(prevMin, Math.min(prevMax, prevPercent));\n          const constrainedNext = Math.max(nextMin, Math.min(nextMax, nextPercent));\n          \n          // If panel has defaultSizePx, use pixels instead of percentage when resizing\n          const prevDefaultSizePx = prevPanelRef.current.dataset.defaultSizePx;\n          const nextDefaultSizePx = nextPanelRef.current.dataset.defaultSizePx;\n          \n          if (prevDefaultSizePx) {\n            // Convert percentage back to pixels for panels with defaultSizePx\n            const prevPx = (constrainedPrev / 100) * startSizes.current.container;\n            prevPanelRef.current.style.flex = `0 0 ${prevPx}px`;\n          } else {\n          prevPanelRef.current.style.flex = `0 0 ${constrainedPrev}%`;\n          }\n          \n          if (nextDefaultSizePx) {\n            // Convert percentage back to pixels for panels with defaultSizePx\n            const nextPx = (constrainedNext / 100) * startSizes.current.container;\n            nextPanelRef.current.style.flex = `0 0 ${nextPx}px`;\n          } else {\n          nextPanelRef.current.style.flex = `0 0 ${constrainedNext}%`;\n          }\n        }\n      };\n\n      const handleMouseUp = () => {\n        setIsResizing(false);\n        startPos.current = null;\n        startSizes.current = null;\n        prevPanelRef.current = null;\n        nextPanelRef.current = null;\n        containerRef.current = null;\n      };\n\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n\n      return () => {\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n      };\n    }, [isResizing, direction, setIsResizing, ref]);\n\n    return (\n      <div\n        ref={ref || handleRef}\n        className={clsx(\n          \"relative flex shrink-0 items-center justify-center\",\n          direction === \"horizontal\" && \"w-[2px] cursor-col-resize\",\n          direction === \"vertical\" && \"h-[2px] cursor-row-resize\",\n          direction === \"both\" && \"w-[2px] h-[2px] cursor-nwse-resize\",\n          \"bg-transparent\",\n          \"hover:bg-[color:var(--color-fg-muted)]\",\n          \"transition-colors duration-[var(--motion-duration-base)]\",\n          disabled && \"cursor-not-allowed opacity-50\",\n          className\n        )}\n        onMouseDown={handleMouseDown}\n        {...props}\n      >\n        <div\n          className={clsx(\n            \"absolute\",\n            direction === \"horizontal\" && \"h-8 w-1\",\n            direction === \"vertical\" && \"h-1 w-8\",\n            direction === \"both\" && \"h-8 w-8\"\n          )}\n        />\n      </div>\n    );\n  }\n);\n\nResizableHandle.displayName = \"ResizableHandle\";\n\nexport const ResizablePanel = React.forwardRef<HTMLDivElement, ResizablePanelProps>(\n  function ResizablePanel({ children, defaultSize, minSize, maxSize, defaultSizePx, minSizePx, className, ...props }, ref) {\n    const panelRef = React.useRef<HTMLDivElement>(null);\n    const containerRef = React.useRef<HTMLElement | null>(null);\n    const [computedSize, setComputedSize] = React.useState<number | undefined>(defaultSize);\n    const [isMounted, setIsMounted] = React.useState(false);\n    const { direction } = React.useContext(ResizableContext);\n\n    // Calculate initial size immediately if defaultSizePx is provided\n    React.useLayoutEffect(() => {\n      if (!defaultSizePx) {\n        setComputedSize(defaultSize);\n        setIsMounted(true);\n        return;\n      }\n\n      // When defaultSizePx is provided, don't calculate percentage - use pixels directly\n      // This ensures the panel always starts at the exact pixel size\n          setIsMounted(true);\n    }, [defaultSizePx, defaultSize, ref]);\n\n    return (\n      <div\n        ref={ref || panelRef}\n        className={clsx(\"relative overflow-auto\", className)}\n        style={{\n          // When defaultSizePx is provided, use fixed pixel width instead of percentage\n          // This ensures the panel always starts at the exact pixel size\n          flex: defaultSizePx ? `0 0 ${defaultSizePx}px` : (computedSize ? `0 0 ${computedSize}%` : \"1 1 0%\"),\n          minWidth: direction === \"horizontal\" ? (minSize ? `${minSize}%` : minSizePx ? `${minSizePx}px` : undefined) : undefined,\n          maxWidth: direction === \"horizontal\" ? (maxSize ? `${maxSize}%` : undefined) : undefined,\n          minHeight: direction === \"vertical\" ? (minSize ? `${minSize}%` : minSizePx ? `${minSizePx}px` : undefined) : undefined,\n          maxHeight: direction === \"vertical\" ? (maxSize ? `${maxSize}%` : undefined) : undefined,\n          // Force width when defaultSizePx is set to ensure exact pixel size\n          width: defaultSizePx && direction === \"horizontal\" ? `${defaultSizePx}px` : undefined,\n          height: defaultSizePx && direction === \"vertical\" ? `${defaultSizePx}px` : undefined,\n        }}\n        data-min-size={minSize}\n        data-max-size={maxSize}\n        data-min-size-px={minSizePx}\n        data-default-size-px={defaultSizePx}\n        {...props}\n      >\n        {children}\n      </div>\n    );\n  }\n);\n\nResizablePanel.displayName = \"ResizablePanel\";\n\n"
    }
  ]
}