{
  "name": "button",
  "type": "registry:component",
  "dependencies": [
    "react",
    "react-dom",
    "@fragment_ui/ui"
  ],
  "files": [
    {
      "path": "components/ui/Button.tsx",
      "content": "import * as React from \"react\";\nimport clsx from \"clsx\";\nimport { Spinner } from \"./spinner\";\n\ntype Variant = \"solid\" | \"outline\" | \"ghost\" | \"secondary\";\ntype Size = \"sm\" | \"md\" | \"lg\";\ntype Radius = \"none\" | \"sm\" | \"md\" | \"lg\" | \"full\";\n\nexport interface ButtonProps\n  extends React.ButtonHTMLAttributes<HTMLButtonElement> {\n  /**\n   * Render as a child element (e.g. `next/link`) to avoid invalid nested interactive elements.\n   * When enabled, `Button` will clone the single child element and apply button styles + content.\n   *\n   * @example\n   * ```tsx\n   * <Button asChild variant=\"secondary\">\n   *   <Link href=\"/docs/setup\">Setup</Link>\n   * </Button>\n   * ```\n   */\n  asChild?: boolean;\n  variant?: Variant;\n  size?: Size;\n  radius?: Radius;\n  leadingIcon?: React.ReactNode;\n  trailingIcon?: React.ReactNode;\n  loading?: boolean;\n  loadingText?: string;\n}\n\nconst radiusClasses = {\n  none: \"rounded-none\",\n  sm: \"rounded-[var(--radius-sm)]\",\n  md: \"rounded-[var(--radius-md)]\",\n  lg: \"rounded-[var(--radius-lg)]\",\n  full: \"rounded-full\",\n} as const;\n\nconst classesBy = {\n  base: \"inline-flex items-center justify-center select-none font-medium\",\n  transition: \"transition-all duration-[var(--motion-duration-base,200ms)] ease-[var(--motion-easing-ease-in-out,cubic-bezier(0.4,0,0.2,1))]\",\n  focus: \"focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-[color:var(--color-brand-primary)] focus-visible:ring-offset-2 focus-visible:ring-offset-[color:var(--color-surface-1)]\",\n  size: {\n    sm: \"h-[var(--space-8)] px-[var(--space-3)] gap-[var(--space-2)] leading-[1.5]\",\n    md: \"h-[calc(var(--space-8)+var(--space-1))] px-[var(--space-4)] gap-[var(--space-2)] leading-[1.5]\",\n    lg: \"h-[calc(var(--space-8)+var(--space-3))] px-[calc(var(--space-6)-var(--space-1))] gap-[var(--space-2)] leading-[1.5]\",\n  },\n  variant: {\n    solid:\n      \"bg-[color:var(--color-button-solid-bg)] text-[color:var(--color-button-solid-text)] shadow-[var(--shadow-sm,0_1px_2px_rgba(0,0,0,.1))] hover:bg-[color:var(--color-button-solid-hover)] hover:shadow-[var(--shadow-md,0_4px_10px_rgba(0,0,0,.15))] active:bg-[color:var(--color-button-solid-hover)] active:scale-[0.98] disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:opacity-50 disabled:hover:shadow-[var(--shadow-sm,0_1px_2px_rgba(0,0,0,.1))]\",\n    outline:\n      \"border border-[color:var(--color-border-base)] bg-transparent text-[color:var(--color-fg-base)] hover:bg-[color:var(--color-surface-2)] hover:border-[color:var(--color-border-base)] active:bg-[color:var(--color-surface-2)] disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent\",\n    ghost:\n      \"bg-transparent text-[color:var(--color-fg-base)] hover:bg-[color:var(--color-surface-1)] active:bg-[color:var(--color-surface-1)] disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-transparent\",\n    secondary:\n      \"bg-[color:var(--color-surface-1)] text-[color:var(--color-fg-base)] !border-0 hover:bg-[color:var(--color-surface-2)] active:bg-[color:var(--color-surface-2)] disabled:opacity-50 disabled:cursor-not-allowed disabled:hover:bg-[color:var(--color-surface-1)]\",\n  },\n} as const;\n\nexport const Button = React.memo(\n  React.forwardRef<HTMLButtonElement, ButtonProps>(\n    function Button(\n      {\n        asChild = false,\n        variant = \"solid\",\n        size = \"md\",\n        radius = \"sm\",\n        leadingIcon,\n        trailingIcon,\n        className,\n        children,\n        loading = false,\n        loadingText,\n        disabled,\n        type,\n        ...props\n      },\n      ref\n    ) {\n      const isDisabled = disabled || loading;\n      const spinnerSize = size === \"sm\" ? \"sm\" : size === \"lg\" ? \"md\" : \"sm\";\n      \n      // Extract children from props to prevent it from being spread into the button element\n      // React.createElement passes children in props, but we want to render it explicitly\n      const { children: propsChildren, ...restProps } = props as any;\n      const finalChildren = children || propsChildren;\n      \n      // Check if children is a fragment with multiple elements (for justify-between support)\n      const isFragment = React.isValidElement(finalChildren) && \n        finalChildren.type === React.Fragment;\n      const childrenArray = React.Children.toArray(finalChildren);\n      const hasMultipleChildren = childrenArray.length > 1;\n      \n      // Check if button has only icon (no text children)\n      // Icon-only button: has icon as leadingIcon/trailingIcon with no children, OR has only React element as children (icon component)\n      // Helper function to recursively check for text content in React elements\n      const hasTextInElement = (element: React.ReactNode): boolean => {\n        if (typeof element === 'string') {\n          return element.trim() !== '';\n        }\n        if (typeof element === 'number') {\n          return true;\n        }\n        if (React.isValidElement(element)) {\n          // Check children of the element\n          if (element.props?.children) {\n            const elementChildren = React.Children.toArray(element.props.children);\n            return elementChildren.some(child => hasTextInElement(child));\n          }\n        }\n        return false;\n      };\n      \n      const hasTextContent = childrenArray.some(child => hasTextInElement(child));\n      \n      // Check if children contains only React elements (icons) without text\n      const hasOnlyReactElements = childrenArray.length > 0 && \n        childrenArray.every(child => React.isValidElement(child)) &&\n        !hasTextContent;\n      \n      // Button is icon-only if:\n      // 1. Has leadingIcon/trailingIcon and no text children, OR\n      // 2. Has only React elements (icons) as children and no leadingIcon/trailingIcon\n      const hasOnlyIcon = \n        ((leadingIcon || trailingIcon) && (!finalChildren || !hasTextContent)) ||\n        (hasOnlyReactElements && !leadingIcon && !trailingIcon);\n      \n      // Size classes for icon-only buttons (square buttons)\n      const iconOnlySizeClasses = {\n        sm: \"h-[var(--space-8)] w-[var(--space-8)] p-[var(--space-0)] gap-[var(--space-0)]\",\n        md: \"h-[calc(var(--space-8)+var(--space-2))] w-[calc(var(--space-8)+var(--space-2))] p-[var(--space-0)] gap-[var(--space-0)]\",\n        lg: \"h-[calc(var(--space-8)+var(--space-4))] w-[calc(var(--space-8)+var(--space-4))] p-[var(--space-0)] gap-[var(--space-0)]\",\n      } as const;\n      \n      const cls = clsx(\n        classesBy.base,\n        classesBy.transition,\n        classesBy.focus,\n        hasOnlyIcon ? iconOnlySizeClasses[size] : classesBy.size[size],\n        radiusClasses[radius],\n        classesBy.variant[variant],\n        className\n      );\n      \n      // Font size styles - use inline style for CSS variables to ensure they work\n      const fontSizeStyle = hasOnlyIcon ? {} : {\n        fontSize: size === \"sm\" ? \"12px\" : size === \"md\" ? \"var(--typography-size-sm)\" : \"var(--typography-size-md)\"\n      };\n      \n      const shouldWrapInSpan = !isFragment && !hasMultipleChildren;\n\n      // --- asChild mode (clone a single child element, e.g. next/link) ---\n      if (asChild) {\n        if (!React.isValidElement(finalChildren)) {\n          // Fallback to regular button rendering if usage is incorrect\n          // (prevents runtime crash in production)\n          return (\n            <button\n              ref={ref}\n              className={cls}\n              style={fontSizeStyle}\n              disabled={isDisabled}\n              data-button-variant={variant}\n              type={type}\n              {...restProps}\n            >\n              {loading ? (\n                <>\n                  <Spinner size={spinnerSize} className=\"mr-2\" />\n                  <span>{loadingText || finalChildren}</span>\n                </>\n              ) : (\n                <>\n                  {leadingIcon ? <span>{leadingIcon}</span> : null}\n                  {shouldWrapInSpan ? <span>{finalChildren}</span> : finalChildren}\n                  {trailingIcon ? <span>{trailingIcon}</span> : null}\n                </>\n              )}\n            </button>\n          );\n        }\n\n        const child = finalChildren as React.ReactElement<any>;\n        const {\n          className: childClassName,\n          style: childStyle,\n          onClick: childOnClick,\n          children: childChildren,\n          ...childRest\n        } = child.props || {};\n\n        const { onClick: restOnClick, style: restStyle, ...restNoClickNoStyle } = restProps as any;\n\n        const labelChildren = childChildren;\n        const labelIsFragment = React.isValidElement(labelChildren) && labelChildren.type === React.Fragment;\n        const labelChildrenArray = React.Children.toArray(labelChildren);\n        const labelHasMultipleChildren = labelChildrenArray.length > 1;\n        const shouldWrapLabelInSpan = !labelIsFragment && !labelHasMultipleChildren;\n\n        const composedChildren = loading ? (\n          <>\n            <Spinner size={spinnerSize} className=\"mr-2\" />\n            <span>{loadingText || labelChildren}</span>\n          </>\n        ) : (\n          <>\n            {leadingIcon ? <span>{leadingIcon}</span> : null}\n            {shouldWrapLabelInSpan ? <span>{labelChildren}</span> : labelChildren}\n            {trailingIcon ? <span>{trailingIcon}</span> : null}\n          </>\n        );\n\n        const disabledClasses = isDisabled ? \"pointer-events-none opacity-50\" : \"\";\n        const mergedClassName = clsx(cls, disabledClasses, childClassName);\n        const mergedStyle = { ...(childStyle || {}), ...(fontSizeStyle || {}), ...(restStyle || {}) };\n\n        const mergedOnClick = (event: any) => {\n          if (isDisabled) {\n            event?.preventDefault?.();\n            event?.stopPropagation?.();\n            return;\n          }\n          childOnClick?.(event);\n          restOnClick?.(event);\n        };\n\n        return React.cloneElement(\n          child,\n          {\n            ...childRest,\n            ...restNoClickNoStyle,\n            className: mergedClassName,\n            style: mergedStyle,\n            onClick: mergedOnClick,\n            \"data-button-variant\": variant,\n            ...(isDisabled ? { \"aria-disabled\": true, tabIndex: -1 } : null),\n          },\n          composedChildren\n        );\n      }\n\n      // --- regular button ---\n      return (\n        <button \n          ref={ref} \n          className={cls}\n          style={fontSizeStyle}\n          disabled={isDisabled}\n          data-button-variant={variant}\n          type={type}\n          {...restProps}\n        >\n          {loading ? (\n            <>\n              <Spinner size={spinnerSize} className=\"mr-2\" />\n              <span>{loadingText || finalChildren}</span>\n            </>\n          ) : (\n            <>\n              {leadingIcon ? <span>{leadingIcon}</span> : null}\n              {shouldWrapInSpan ? <span>{finalChildren}</span> : finalChildren}\n              {trailingIcon ? <span>{trailingIcon}</span> : null}\n            </>\n          )}\n        </button>\n      );\n    }\n  )\n);\n\n"
    }
  ]
}